import matplotlib.pyplot as plt
import pandas as pd
import numpy as np
from trip import trip
from parse import *
from filter import *
from matplotlib.patches import Ellipse
import matplotlib.transforms as transforms
import scipy.stats as scipy
import seaborn as sns
seat_color = {0 : "blue", 1 : "green", 2 : "red"}

hex_colors = [
        "#FF5733",  # Bright Red
        "#33FF57",  # Bright Green
        "#3357FF",  # Bright Blue
        "#FF33A8",  # Bright Pink
        "#33FFF6",  # Bright Cyan
        "#FFAF33",  # Bright Orange
        "#8D33FF",  # Bright Purple
        "#A8FF33",  # Bright Lime
        "#FF6F33",  # Bright Coral
        "#33FFAF",  # Bright Mint
        "#5733FF",  # Bright Violet
        "#FFD133",  # Bright Gold
        "#33D1FF",  # Bright Sky Blue
        "#FF33D1",  # Bright Magenta
        "#33FF33",  # Bright Green
        "#D133FF",  # Bright Lavender
        "#FFA833",  # Bright Amber
        "#33FFA8",  # Bright Aqua
        "#6F33FF",  # Bright Indigo
        "#33FFD1",  # Bright Turquoise
        "#FF3383",  # Bright Salmon
        "#33FF83",  # Bright Greenish
        "#3333FF",  # Bright Cobalt
        "#FF338F",  # Bright Pinkish
        "#33FFE1",  # Bright Light Cyan
        "#FF8F33",  # Bright Tangerine
        "#9F33FF",  # Bright Violet
        "#B8FF33",  # Bright Chartreuse
        "#FF7F33",  # Bright Tangerine
        "#33FFCF",  # Bright Teal
        "#6733FF",  # Bright Indigo
        "#FFDF33",  # Bright Mustard
        "#33B1FF",  # Bright Cerulean
        "#FF33F1",  # Bright Fuchsia
        "#33FF63",  # Bright Light Green
        "#FF3357"   # Bright Crimson
    ]

styles = ['Solarize_Light2', '_classic_test_patch', '_mpl-gallery', '_mpl-gallery-nogrid', 'bmh', 'classic', 'dark_background', 'fast', 'fivethirtyeight', 'ggplot', 'grayscale', 'seaborn-v0_8', 'seaborn-v0_8-bright', 'seaborn-v0_8-colorblind', 
              'seaborn-v0_8-dark', 'seaborn-v0_8-dark-palette', 'seaborn-v0_8-darkgrid', 'seaborn-v0_8-deep', 'seaborn-v0_8-muted', 'seaborn-v0_8-notebook', 'seaborn-v0_8-paper', 'seaborn-v0_8-pastel', 'seaborn-v0_8-poster', 'seaborn-v0_8-talk', 
              'seaborn-v0_8-ticks', 'seaborn-v0_8-white', 'seaborn-v0_8-whitegrid', 'tableau-colorblind10']

"""
Master function to generate graphs for project report.
Generates two trip route visualizations (pre/mid trip, rssi_diff), KDE of rssi_diff by point classification, KDE of trip accuracy by each model,
    tables for accuracy and macro-averaged f1 by split for each model, and confusion matrix heatmaps for each model.

Args:
    rf_data: full-scope prediction data generated by rf as is produced by the eval() function
    mlp_data: full-scope prediction data generated by mlp as is produced by the eval() function
    lstm_data: full-scope prediction data generated by lstm as is produced by the eval() function
    trips: array of trip objects

Returns: 
    None, graphics are displayed 
"""
def generate_graphs(rf_data, mlp_data, lstm_data, trips):
    data = [rf_data, mlp_data, lstm_data]
    raw_data = pd.concat(get_tagged_dataset(trips))
    trimmed_zeros = pd.concat(get_tagged_dataset(trips, trim_double_zeros = True))
    model_color = {0: "#FF4A26", 1: "#33B1FF", 2:  "#8D33FF"}
    model_name = {0: 'RF', 1: 'MLP', 2: 'LSTM'}
    seat_name = {0: "Front", 1: "Middle", 2: "Back"}
    chosen_trip = trips[90] # Good length (seat: back) trip chosen for data visualization.
    chosen_trip_data = get_tagged_dataset([chosen_trip])[0]

    plt.rcParams['font.family'] = 'Avenir'

    """
    ----------------------------------------------
    PLOT 1: Sample trip plot for pre/mid trip
    ----------------------------------------------
    """
    # PLOT 1: Sample trip plot for pre/mid trip
    fig = plt.figure(figsize = (7, 6))
    ax = fig.add_subplot(111)

    fig, ax = graph_trip(chosen_trip, fig, ax)

    ax.legend(prop = {'family': 'Avenir', 'size': 15})
    ax.grid(True, alpha = 0.3)
    ax.set_xlabel("Latitude", fontsize = 15, fontfamily = "Avenir")
    ax.set_ylabel("Longitude", fontsize = 15, fontfamily = "Avenir")

    plt.tight_layout()
    plt.subplots_adjust(bottom = 0.2)
    fig.text(0.5, 0.05, "Plot 1: Sample Trip (Trip #90, User: Fly)",
             ha='center', va='center', fontsize = 20, fontfamily = "Avenir next")
    
    plt.show()


    """
    ----------------------------------------------
    PLOT 2: Sample trip plot for RSSI Diff
    ----------------------------------------------
    """
    fig = plt.figure(figsize = (7, 6))
    ax = fig.add_subplot(111)

    fig, ax = graph_trip_rssi_diff(chosen_trip_data, fig, ax)
    
    ax.legend(prop = {'family': 'Avenir', 'size': 15})
    ax.grid(True, alpha = 0.3)
    ax.set_xlabel("Latitude", fontsize = 15, fontfamily = "Avenir")
    ax.set_ylabel("Longitude", fontsize = 15, fontfamily = "Avenir")

    plt.tight_layout()
    plt.subplots_adjust(bottom = 0.2)
    fig.text(0.5, 0.05, "Plot 2: Sample Trip RSSI Diff (Seat: back)",
             ha='center', va='center', fontsize = 20, fontfamily = "Avenir next")
    
    plt.show()


    """
    ----------------------------------------------
    Figure 1: KDE of RSSI difference by seat location
    ----------------------------------------------
    """
    fig = plt.figure(figsize = (9, 6))
    ax = fig.add_subplot(111)

    for seat in range(3):
        seat_data = trimmed_zeros.loc[trimmed_zeros["seat"] == seat, "rssi_diff"]
        kde = scipy.gaussian_kde(seat_data)
        x_range = np.linspace(min(seat_data), max(seat_data), 200)

        ax.plot(x_range, kde(x_range), seat_color[seat], lw = 2, label = seat_name[seat])
        ax.fill_between(x_range, kde(x_range), color = seat_color[seat], alpha = 0.3)

    ax.legend(prop = {'family': 'Avenir', 'size': 15})
    ax.grid(True, alpha = 0.3)
    ax.set_xlabel("RSSI Difference (Minor 2 - Minor 1)", fontsize = 15, fontfamily = "Avenir")
    ax.set_ylabel("Probability Density", fontsize = 15, fontfamily = "Avenir")

    plt.tight_layout()
    plt.subplots_adjust(bottom = 0.2)
    fig.text(0.5, 0.05, "Figure 1: Kernel Density of RSSI Difference (Non-Zero) by Seat",
             ha='center', va='center', fontsize = 20, fontfamily = "Avenir next")
    
    plt.show()
    
    
    """
    ----------------------------------------------
    Figure 2: KDE of model accuracy by trip
    ----------------------------------------------
    """
    fig = plt.figure(figsize = (9, 6))
    ax = fig.add_subplot(111)

    for i, model in enumerate(data):
        kde = scipy.gaussian_kde(model['trip_acc'])
        x_range = np.linspace(min(model['trip_acc']), max(model['trip_acc']), 200)

        ax.plot(x_range, kde(x_range), model_color[i], lw = 2, label = model_name[i])
        ax.fill_between(x_range, kde(x_range), color = model_color[i], alpha = 0.3)

    ax.legend(prop = {'family': 'Avenir', 'size': 15})
    
    ax.grid(True, alpha = 0.3)
    ax.set_xlabel("Trip Accuracy Scores", fontsize = 15, fontfamily = "Avenir")
    ax.set_ylabel("Probability Density", fontsize = 15, fontfamily = "Avenir")

    plt.tight_layout()
    plt.subplots_adjust(bottom = 0.2)
    fig.text(0.5, 0.05, "Figure 2: Kernel Density of Trip Accuracy Prediction by Model", ha = 'center', va = 'center', fontsize = 20, fontfamily = 'Avenir next')
    plt.show()
    


    """
    ----------------------------------------------
    Table 1: Accuracy of predictions from each model by split
    ----------------------------------------------
    """
    table = [[], [], []]
    for i, model in enumerate(data):
        row = model['split_acc'] + [np.mean(model['split_acc'])] + [np.std(model['split_acc'])]
        row = [round(el*100, 2) for el in row]
        table[i] = row
        
    rows = ["RF", "MLP", "LSTM"]
    cols = ["Split 0", "Split 1", "Split2", "Split3", "Split4", "Avg", "Std"]
    df = pd.DataFrame(table)

    fig = plt.figure(figsize = (8, 2))
    ax = fig.add_subplot(111)
    fig, ax = graph_table(df, fig = fig, ax = ax, row_labels=rows, col_labels=cols)

    plt.tight_layout()
    plt.subplots_adjust(bottom = 0.2)
    fig.text(0.5, 0.075, "Table 1: Accuracy Scores for Each Model", ha = 'center', va = 'center', fontsize = 20, fontfamily = 'Avenir next')
    plt.show()


    # MODEL F1 BY SPLIT, WITH AVERAGE AND STD
    """
    ----------------------------------------------
    Table 2: Macro-averaged f1 of predictions from each model by split
    ----------------------------------------------
    """
    table = [[], [], []]
    for i, model in enumerate(data):
        row = model['split_f1'] + [np.mean(model['split_f1'])] + [np.std(model['split_f1'])]
        row = [round(el*100, 2) for el in row]
        table[i] = row

    df = pd.DataFrame(table)
    fig = plt.figure(figsize = (8, 2))
    ax = fig.add_subplot(111)
    fig, ax = graph_table(df, fig = fig, ax = ax, row_labels=rows, col_labels=cols)

    plt.tight_layout()
    plt.subplots_adjust(bottom = 0.2)
    fig.text(0.5, 0.075, "Table 2: Macro-Averaged F1 Scores for Each Model", ha = 'center', va = 'center', fontsize = 20, fontfamily = 'Avenir next')
    plt.show()
    

    """
    Matrices 1, 2, 3: Confusion matrix heat map for each model's aggregate predictions
    """
    for i, model in enumerate(data):
        fig = plt.figure(figsize = (7, 4))
        ax = fig.add_subplot(111)

        conf_matrix = model["cmat"][0]
        
        graph_conf_heatmap(conf_matrix, fig, ax)
        
        ax.set_xlabel("Predicted", fontfamily = 'Avenir', fontsize = 15)
        ax.set_ylabel("True", fontfamily = 'Avenir', fontsize = 15)

        plt.tight_layout()
        plt.subplots_adjust(bottom = 0.2)
        fig.text(0.5, 0.035, "Matrix {}: Confusion Matrix Heat Map for {}".format(i + 1, model_name[i]), ha = 'center', va = 'center', fontsize = 20, fontfamily = 'Avenir next')
        plt.show()

"""
Function to graph Kernel Density Estimation of a dataset

Args:
    data: set of data to estimate KDE for
    label: label to be used in legend of plot
    fig: figure object to apply the plot to
    ax: axes object to apply the plot to
    show: boolean indicating whether or not to show the plot
    color: color to be used for the plot
    alpha: opacity of the shading below the plot

Returns:
    fig: figure object with plot applied
    ax: axes object with plot applied
"""
def graph_kde(data, label = "", fig = None, ax = None, show = False, color = "blue", alpha = 0):
    if fig is None:
        fig, ax = plt.subplots()
    
    kde = scipy.gaussian_kde(data)
    x_range = np.linspace(min(data), max(data), 200)

    ax.plot(x_range, kde(x_range), color, lw = 2, label = label)
    ax.fill_between(x_range, kde(x_range), color = color, alpha = alpha)

    if show:
        plt.show()
    
    return fig, ax

"""
Function to graph cumulative Kernel Density Estimation of a dataset

Args:
    data: set of data to estimate KDE for
    label: label to be used in legend of plot
    fig: figure object to apply the plot to
    ax: axes object to apply the plot to
    show: boolean indicating whether or not to show the plot
    color: color to be used for the plot
    alpha: opacity of the shading below the plot

Returns:
    fig: figure object with plot applied
    ax: axes object with plot applied
"""
def graph_kde_cdf(data, label="", fig=None, ax=None, show=False, color="blue", alpha=0):
    if fig is None:
        fig, ax = plt.subplots()
    
    kde = scipy.gaussian_kde(data)
    x_range = np.linspace(min(data), max(data), 200)
    kde_values = kde(x_range)
    
    cdf_values = np.zeros_like(x_range)
    for i in range(len(x_range)):
        cdf_values[i] = np.trapz(kde_values[:i+1], x_range[:i+1])
    
    cdf_values = cdf_values / cdf_values[-1]
    
    ax.plot(x_range, cdf_values, color=color, lw=2, label=label)
    ax.fill_between(x_range, cdf_values, color=color, alpha=alpha)
    
    ax.grid(True, alpha=0.3)
    ax.set_ylim(0, 1)

    if show:
        plt.show()
    
    return fig, ax

"""
Function to graph a table

Args:
    data: data to be used to plot the table, should be 2d
    row_labels: labels for each data row
    col_labels: labels to be used for each column
    fig: figure object to apply the table to
    ax: axes object to apply the table to
    show: boolean indicating whether or not to show the graph

Returns:
    fig: figure object with table applied to it
    ax: axes object with table applied to it
"""
def graph_table(data, row_labels=None, col_labels=None, fig=None, ax=None, 
                show=False, font_family = 'Avenir next', font_size=12):
    if fig is None:
        fig, ax = plt.subplots(figsize=(8, 6))
    
    # Hide axes
    ax.axis('tight')
    ax.axis('off')
    
    # Convert data to numpy array if it isn't already
    data = np.array(data)
    
    # Default labels if none provided
    if row_labels is None:
        row_labels = [f'Row {i+1}' for i in range(data.shape[0])]
    if col_labels is None:
        col_labels = [f'Col {i+1}' for i in range(data.shape[1])]
    
    # Create table
    table = ax.table(cellText=data,
                    rowLabels=row_labels,
                    colLabels=col_labels,
                    cellLoc='center',
                    loc='center')
    
    # Style the table
    table.auto_set_font_size(False)
    table.set_fontsize(font_size)
    
    # Adjust cell heights and widths
    table.scale(1.2, 1.8)
    
    # Style cells
    for key, cell in table._cells.items():
        cell.set_text_props(fontsize = 15, fontfamily='Avenir')
        cell.set_edgecolor('black')
        
        # Make header cells bold
        if cell.get_text().get_text() in row_labels + col_labels:
            cell.set_text_props(fontsize = 15, family = 'Avenir next')
            # cell.get_text().set_weight('bold')
            # cell.get_text().set_fontweight('bold')
            cell.set_facecolor('#E6E6E6')  # Light gray background
    
    plt.tight_layout()
    
    if show:
        plt.show()
    
    return fig, ax


"""
Function to graph confusion matrix for data, coloring cells to represent relative density

Args:
    data: confusion matrix data to be plotted (should be 3x3 for this context)
    xlabels: labels to be used for each cell on the x axis
    ylabels: labels to be used for each cell on the y axis
    fig: figure object to apply the plot to
    ax: axes object to apply the plot to
    show: whether or not to show the plotted data

Returns:
    fig: figure object with heatmap matrix applied
    ax: axes object with heatmap matrix applied
"""
def graph_conf_heatmap(data, fig = None, ax = None, show = False):
    if fig is None:
        fig, ax = plt.subplots()
    
    # Convert to percentages
    row_sums = data.sum(axis=1)
    cm_pct = (data.T / row_sums).T * 100

    cell_labels = []
    for i in range(len(data[0])):
        row_labels = []
        for j in range(len(data[1])):
            lstr = f'{data[i][j]}\n({cm_pct[i][j]:.2f})'
            row_labels.append(lstr)
        cell_labels.append(row_labels)

    
    sns.heatmap(cm_pct, 
            annot=cell_labels,
            annot_kws = {'size': 15, 'fontfamily': 'Avenir'},
            fmt='',
            xticklabels=['Front', 'Middle', 'Back'],
            yticklabels=['Front', 'Middle', 'Back'],
            cmap='YlOrRd',
            ax=ax,
            cbar = True,
            cbar_kws = {'label': 'Proportion of True Values for Each Seat Location'})
    
    if show:
        plt.show()
    
    return fig, ax

"""
Simple function to plot data points using a line.

Args:
    x: series-like object of x data to be plotted
    y: series-like object of y data to be plotted
    color: color to be used for plotting
    xlabel: label to be used on the x axis
    ylabel: label to be used on the y axis
    title: title of the plot
    fig: optional figure object to apply the plot to
    ax: option axes object to apply the plot to
    show: whether or not to show the plot or just apply it to the axes

Returns:
    fig: figure object with plot applied
    ax: axes object with plot applied
"""
def quick_plot(x, y, color = "blue", xlabel = "", ylabel = "", title = "", fig = None, ax = None, show = False):
    show = False
    if ax is None:
        fig, ax = plt.subplots()
        show = True

    ax.plot(x, y, color=color)
    plt.xlabel(xlabel)
    plt.ylabel(ylabel)
    plt.title(title)
    if show:
        plt.show()
    return fig, ax

"""
Simple function to plot data points using a scatter plot.

Args:
    x: series-like object of x data to be plotted
    y: series-like object of y data to be plotted
    color: color to be used for plotting
    xlabel: label to be used on the x axis
    ylabel: label to be used on the y axis
    title: title of the plot
    fig: optional figure object to apply the plot to
    ax: option axes object to apply the plot to
    show: whether or not to show the plot or just apply it to the axes

Returns:
    fig: figure object with plot applied
    ax: axes object with plot applied
"""
def quick_scatter(x, y, color = "blue", xlabel = "", ylabel = "", title = "", fig = None, ax = None, show = False):
    show = False
    if ax is None:
        fig, ax = plt.subplots()
        show = True

    ax.scatter(x, y, color=color)
    plt.xlabel(xlabel)
    plt.ylabel(ylabel)
    plt.title(title)
    if show:
        plt.show()
    
    return fig, ax

"""
Function to graph x and y data along with a best-fit line representing their correlation.

Args:
    x: x data to be plotted
    y: y data to be plotted
    corr_coef: the pre-computed correlation coefficient between the x and y values
    xlabel: label to be shown on the graph's x axis
    ylabel: label to be shown on the graph's y axis
"""
def graph_correlation(x, y, corr_coef, xlabel = "", ylabel = ""):
    vars = np.polyfit(x, y, 1)
    line = np.poly1d(vars)

    plt.figure(figsize = (10, 10))

    plt.scatter(x, y, color="blue")
    plt.plot(x, line(x), color="red", alpha=0.4)
    plt.text(0.05, 0.95, "Correlation: {}".format(corr_coef), transform=plt.gca().transAxes)

    plt.xlabel(xlabel)
    plt.ylabel(ylabel)
    plt.title("Correlation plot for {} and {}".format(xlabel, ylabel))
    plt.show()


"""
Function to plot latitude and longitude data for a given trip.
Pre-trip data plotted in red, mid-trip data plotted in blue.

Args:
    trip: trip object to be plotted
    fig: figure object to apply the plot to
    ax: axes object to apply the plot to
    show: option to show the plot or just apply it

Returns:
    fig: figure object with applied plot
    ax: axes object with applied plot
"""
def graph_trip(trip, fig = None, ax = None, show = False):
    if fig is None:
        fig, ax = plt.subplots()

    stop_data = get_stop_data()
    data = trip.data.copy()

    pre_trip = data.loc[data["timestamp"] < trip.on_bus]
    mid_trip = data.loc[data["timestamp"] >= trip.on_bus]

    ax.set_xlim(min(stop_data["stop_lon"]) - 0.001, max(stop_data["stop_lon"]) + 0.001)
    ax.set_ylim(min(stop_data["stop_lat"]) - 0.001, max(stop_data["stop_lat"]) + 0.001)

    ax.scatter(pre_trip["longitude"], pre_trip["latitude"], color="red", s = 40, label = "Pre-Trip")
    ax.scatter(mid_trip["longitude"], mid_trip["latitude"], color="blue", s = 40, label = "Mid-Trip")

    ax.scatter(stop_data["stop_lon"], stop_data["stop_lat"], color = "#00b812", marker = "^", s = 30, label = "Bus stop")


    if show:
        plt.show()
    
    return fig, ax

"""
Function to plot latitude and longitude data for a given trip.
Color represents rssi difference at each location.

Args:
    trip: trip object to be plotted
    fig: figure object to apply the plot to
    ax: axes object to apply the plot to
    show: option to show the plot or just apply it

Returns:
    fig: figure object with applied plot
    ax: axes object with applied plot
"""
def graph_trip_rssi_diff(data, fig = None, ax = None, show = False):
    if fig is None:
        fig, ax = plt.subplots()

    stop_data = get_stop_data()

    ax.set_xlim(min(stop_data["stop_lon"]) - 0.001, max(stop_data["stop_lon"]) + 0.001)
    ax.set_ylim(min(stop_data["stop_lat"]) - 0.001, max(stop_data["stop_lat"]) + 0.001)

    norm = plt.Normalize(data["rssi_diff"].min(), data["rssi_diff"].max())

    sc = ax.scatter(data["longitude"], data["latitude"], c=data["rssi_diff"], cmap="viridis", norm=norm, s=30)

    ax.scatter(stop_data["stop_lon"], stop_data["stop_lat"], color = "#f53d00", marker = "^", s = 30, label = "Bus stop")

    cbar = plt.colorbar(sc)
    cbar.set_label('RSSI Diff (Back - Front)')

    if show:
        plt.show()

    return fig, ax


"""
Function to graph RSSI readings over time for a single trip.
Red and blue markers represent pre-trip readings for minors one and two respectively,
gold and purple markers represent the same but for mid-trip readings.

Args:
    trip: trip object to graph the rssi for
"""
def graph_rssi(trip):
    data = trip.data.copy()

    first_time = data["timestamp"].min()
    data["timestamp"] = data["timestamp"] - first_time
    on_bus = trip.on_bus - first_time
    
    pre_one = data.loc[(data["minor"] == 1) & (data["timestamp"] < on_bus)]
    pre_two = data.loc[(data["minor"] == 2) & (data["timestamp"] < on_bus)]
    mid_one = data.loc[(data["minor"] == 1) & (data["timestamp"] >= on_bus)]
    mid_two = data.loc[(data["minor"] == 2) & (data["timestamp"] >= on_bus)]

    #Setting rssi = 0 values to -100
    pre_one.loc[pre_one["rssi"] == 0, "rssi"] = -100
    pre_two.loc[pre_two["rssi"] == 0, "rssi"] = -100
    mid_one.loc[mid_one["rssi"] == 0, "rssi"] = -100
    mid_two.loc[mid_two["rssi"] == 0, "rssi"] = -100

    plt.scatter(pre_one["timestamp"], pre_one["rssi"], color="red", marker="x", s = 75, linewidths=.5, label="Minor 1, Pre-trip")
    plt.scatter(pre_two["timestamp"], pre_two["rssi"], color="blue", marker="o", facecolors = 'none', s = 75, linewidths=.5, label="Minor 2, Pre-trip")
    plt.scatter(mid_one["timestamp"], mid_one["rssi"], color="gold", marker="x", s = 75, linewidths=.5, label="Minor 1, Mid-trip")
    plt.scatter(mid_two["timestamp"], mid_two["rssi"], color="purple", marker="o", facecolors = 'none', s = 75, linewidths=.5, label="Minor 2, Mid-trip")

    plt.xlabel("Time (Unix)")
    plt.ylabel("RSSI (dBm)")

    plt.title(str(trip.user) + " - Trip #" + str(trip.trip_idx) + "\n Seat: " + str(trip.seat) + ", Major: " + str(trip.major) + ", Exit marked: " + str(not trip.didNotMarkExit))

    plt.legend(bbox_to_anchor=(.9, 1), loc="upper left")
    plt.subplots_adjust(right=0.8)

    plt.show()


"""
Function to graph RSSI of minors 1 and 2
Takes in a dataframe, which should contain a seat location and an rssi for minors one and two in each row.

Args:
    data: data from sble already joined by minor, should contain full featureset
"""

def graph_minor_rssi(data):
    front = data.loc[data["seat"] == 0]
    middle = data.loc[data["seat"] == 1]
    back = data.loc[data["seat"] == 2]

    axis_max = max(max(front["rssi_1"].tolist()), max(front["rssi_2"].tolist()))
    axis_max = max(axis_max, max(max(middle["rssi_1"].tolist()), max(middle["rssi_2"].tolist())))
    axis_max = max(axis_max, max(max(back["rssi_1"].tolist()), max(back["rssi_2"].tolist())))
    axis_min = min(min(front["rssi_1"].tolist()), min(front["rssi_2"].tolist()))
    axis_min = min(axis_min, min(min(middle["rssi_1"].tolist()), min(middle["rssi_2"].tolist())))
    axis_min = min(axis_min, min(min(back["rssi_1"].tolist()), min(back["rssi_2"].tolist())))

    axis_max += ((axis_max - axis_min)/10)
    axis_min -= ((axis_max - axis_min)/10)

    plt.scatter(front["rssi_1"].tolist(), front["rssi_2"].tolist(), c="blue", marker = "x", s = 75, linewidths=.5)
    plt.scatter(middle["rssi_1"].tolist(), middle["rssi_2"].tolist(), c="green", marker = "x", s = 75, linewidths=.5)
    plt.scatter(back["rssi_1"].tolist(), back["rssi_2"].tolist(), c="red", marker = "x", s = 75, linewidths=.5)
    plt.xlabel("Minor 1 RSSI (dBm)")
    plt.ylabel("Minor 2 RSSI (dBm)")
    plt.xlim(axis_min, axis_max)
    plt.ylim(axis_min, axis_max)

    plt.show()

"""
Function to graph CDF of each seat using the RSSI difference

Args:
    data: data from sble already joined by minor, should contain full featureset
"""

def graph_rssi_cdf(data):
    front = data.loc[data["seat"] == 0, "rssi_diff"].tolist()
    middle = data.loc[data["seat"] == 1, "rssi_diff"].tolist()
    back = data.loc[data["seat"] == 2, "rssi_diff"].tolist()

    min_val = min([min(front), min(middle), min(back)])
    max_val = max([max(front), max(middle), max(back)])

    f_range, f_cdf = get_cdf(front)
    m_range, m_cdf = get_cdf(middle)
    b_range, b_cdf = get_cdf(back)

    plt.plot(f_range, f_cdf, c="blue")
    plt.plot(m_range, m_cdf, c="red")
    plt.plot(b_range, b_cdf, c="green")
    plt.xlim(min_val, max_val)
    plt.ylim(0, 1)

    plt.show()


"""
Function to extract cdf values at each integer difference value in the dataset.

Args:
    arr: array of data to graph cdf for

Returns:
    rng: list of buckets used in cdf creation
    cdf: cdf values in each bucket from rng
"""
def get_cdf(arr):
    min_val = int(min(arr))
    max_val = int(max(arr))

    arr = sort(arr)

    cdf = [0]*(int(max_val - min_val) + 1)
    rng = list(range(min_val, max_val + 1))

    count = 0
    
    for i in range(int(max_val - min_val)):
        count += arr.count(rng[i])
        cdf[i] = count / len(arr)

    
    cdf[-1] = 1

    return rng, cdf

"""
Function to remove outliers from dataset.

Args:
    arr: array of data points to be trimmed
"""
def remove_outliers(arr):
    avg = sum(arr)/len(arr)
    std = 0

    for i in arr:
        std += abs(avg - i)
    
    std = std / len(arr)

    lower = avg - (3*std)
    upper = avg + (3*std)

    trimmed = list(filter(lambda x: x > lower and x < upper, arr))

    return trimmed


"""
Quick simple sorting function

Args:
    list: list of data to be sorted

Returns:
    sorted: the inputted list, sorted
"""
def sort(list):
    if len(list) < 2:
        return list
    else:
        mid = len(list) // 2
        left = list[:mid]
        right = list[mid:]

        left = sort(left)
        right = sort(right)

        sorted = []
        i = j = 0

        while (i < len(left)) & (j < len(right)):
            if (left[i] < right[j]):
                sorted.append(left[i])
                i += 1
            else:
                sorted.append(right[j])
                j += 1
        
        while i < len(left):
            sorted.append(left[i])
            i += 1
        
        while j < len(right):
            sorted.append(right[j])
            j += 1
        
        return sorted
            











